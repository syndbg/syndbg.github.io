<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DevOps on Anton Antonov's mindspace</title><link>https://syndbg.github.io/categories/devops/</link><description>Recent content in DevOps on Anton Antonov's mindspace</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 13 Jan 2025 03:00:00 +0000</lastBuildDate><atom:link href="https://syndbg.github.io/categories/devops/index.xml" rel="self" type="application/rss+xml"/><item><title>Practically, Go 1.25's Container-Aware GOMAXPROCS: What You Need to Know</title><link>https://syndbg.github.io/posts/2025-01-13-go-1-25/</link><pubDate>Mon, 13 Jan 2025 03:00:00 +0000</pubDate><guid>https://syndbg.github.io/posts/2025-01-13-go-1-25/</guid><description>&lt;p>Go 1.25 just dropped with expected changes to GOMAXPROCS, which significantly change how Go applications behave in containerized environments. The runtime now &lt;strong>automatically detects and respects container CPU limits&lt;/strong> when setting &lt;code>GOMAXPROCS&lt;/code>. This isn&amp;rsquo;t just a minor improvementâ€”it&amp;rsquo;s a shift that &lt;strong>may&lt;/strong> dramatically improve performance for millions of containerized Go applications.&lt;/p>
&lt;p>And this isn&amp;rsquo;t the only amazing change, but this is the one I&amp;rsquo;ll focus on in this post.&lt;/p>
&lt;h2 id="the-problem-that-plagued-go-for-years">The Problem That Plagued Go for Years&lt;/h2>
&lt;p>Before Go 1.25, there was a fundamental mismatch between Go&amp;rsquo;s runtime and containerized environments:&lt;/p></description></item></channel></rss>